# -*- coding: utf-8 -*-
"""SVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aKeKmGAK5FBmb0WVSp-ftWrk473VG2BS

The code below is used for data scrapping of butterfly images from Baidu
"""

# import re
# import requests
# from bs4 import BeautifulSoup
# from urllib.parse import urlparse
# import os

# def scrape(keyword): 
#     url = 'https://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=' + word + '&ct=201326592&v=flip'
#     html = requests.get(url).text
#     pic_url = re.findall('"objURL":"(.*?)",',html,re.S)
    
#     i = 0
    
#     for picture in pic_url:
#         try:
#             pic = requests.get(picture, timeout=10)
#         except requests.exceptions.ConnectionError:
#             print ('Picture download timed out, could not download image')
#             continue

#         string = 'pictures' + keyword + '_'+str(i) + '.jpg'
#         fp = open(string,'wb')
#         fp.write(pic.content)
#         fp.close()
#         #print(str(i+1) + " /" + str(threshold) + " pictures successfully downloaded")
#         print(str(i+1) + " pictures successfully downloaded")
#         i += 1

# if __name__ == '__main__':
#     #threshold = input("How many pictures do you want to download?")
#     word = input("User please input search query: ")
#     scrape(word)

"""The code below is used for SVM"""

# Commented out IPython magic to ensure Python compatibility.
import os
from os import walk
import cv2
from glob import glob

import matplotlib as mpl
import matplotlib.pyplot as plt
from IPython.display import display
# %matplotlib inline

import pandas as pd
import numpy as np

from PIL import Image

from skimage.feature import hog
from skimage.color import rgb2grey

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.svm import SVC
from sklearn.svm import LinearSVC

from sklearn.metrics import roc_curve, auc

labels = pd.read_csv("/content/sample_data/butterfly.csv", index_col = 0)
#insert your own directory in the parentheses
def get_image(filename, root="/content/sample_data/butterflies/"):
    size = 128, 128
    file_path = os.path.join(root, filename)
    img = Image.open(file_path)
    img = img.resize(size, Image.ANTIALIAS)
    return np.array(img)

type_one = get_image("0020175.png")
plt.imshow(type_one)
plt.show()

print('Color type one image has shape: ', type_one)

# convert the type one image to greyscale
grey_type_one = rgb2grey(type_one)

plt.imshow(grey_type_one, cmap=mpl.cm.gray)

print('Greyscale type one image has shape: ', grey_type_one)

# run HOG using our greyscale image
hog_features, hog_image = hog(grey_type_one,
                              visualize=True,
                              block_norm='L2-Hys',
                              pixels_per_cell=(16, 16))

plt.imshow(hog_image, cmap=mpl.cm.gray)

def create_features(img):
    # flatten three channel color image
    color_features = img.flatten()
    # convert image to greyscale
    grey_image = rgb2grey(img)
    # get HOG features from greyscale image
    hog_features = hog(grey_image, block_norm='L2-Hys', pixels_per_cell=(16, 16))
    # combine color and hog features into a single array
    flat_features = np.hstack(color_features)
    return flat_features

type_one1 = get_image("0020104.png")
type_one2 = get_image("0010030.png")
type_one3 = get_image("0010040.png")
type_one4 = get_image("0010037.png")

type_one_features = create_features(type_one)
type_one_features1 = create_features(type_one1)
type_one_features2 = create_features(type_one2)
type_one_features3 = create_features(type_one3)
type_one_features4 = create_features(type_one4)

print(len(type_one_features))
print(len(type_one_features1))
print(len(type_one_features2))
print(len(type_one_features3))
print(len(type_one_features4))

def create_feature_matrix(label_dataframe):
    features_list = []
    
    for img_id in label_dataframe.index:
        # load image
        img = get_image(img_id)
        # get features for image
        image_features = create_features(img)
        features_list.append(image_features)
        
    # convert list of arrays into a matrix
    feature_matrix = np.array(features_list)
    return feature_matrix

# run create_feature_matrix on our dataframe of images
feature_matrix = create_feature_matrix(labels)

# get shape of feature matrix
irregular = []
for i in range(len(feature_matrix)):
  if (len(feature_matrix[i]) < 30000):
    irregular.append(i)

print(irregular)


print('Feature matrix shape is: ', feature_matrix.shape)

# define standard scaler
ss = StandardScaler()
# run this on our feature matrix
butterflies_stand = ss.fit_transform(feature_matrix)

pca = PCA(n_components=500)
# use fit_transform to run PCA on our standardized matrix
butterflies_pca = ss.fit_transform(butterflies_stand)
# look at new shape
print('PCA matrix shape is: ', butterflies_pca.shape)

X = pd.DataFrame(butterflies_pca)
y = pd.Series(labels.genus.values)
X_train, X_test, y_train, y_test = train_test_split(X,
                                                    y,
                                                    test_size=.3,
                                                    random_state=1234123)

# look at the distrubution of labels in the train set
pd.Series(y_train).value_counts()

# normal SVC
svm = SVC(kernel='linear', probability=True, random_state=42, decision_function_shape='ovr')
svm.fit(X_train, y_train)

# linearSVC
# lin_svm = LinearSVC(multi_class='crammer_singer')
# lin_svm.fit(X_train, y_train)

# dec = svm.decision_function()
# dec.shape[1]

# generate predictions
y_pred = svm.predict(X_test)
#print(y_pred)

# calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print('SVC model accuracy is: ', accuracy)

# generate predictions
y_pred = lin_svm.predict(X_test)
#print(y_pred)

# calculate accuracy
accuracy = accuracy_score(y_test, y_pred)
print('LinearSVC model accuracy is: ', accuracy)

# predict probabilities for X_test using predict_proba
probabilities = svm.predict_proba(X_test)

#print(probabilities)

# select the probabilities for label 1.0
y_proba = probabilities[:, 1]

# calculate false positive rate and true positive rate at different thresholds
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_proba, pos_label=1)

# calculate AUC
roc_auc = auc(false_positive_rate, true_positive_rate)

plt.title('Receiver Operating Characteristic')
# plot the false positive rate on the x axis and the true positive rate on the y axis
roc_plot = plt.plot(false_positive_rate,
                    true_positive_rate,
                    label='AUC = {:0.2f}'.format(roc_auc))

plt.legend(loc=0)
plt.plot([0,1], [0,1], ls='--')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate');